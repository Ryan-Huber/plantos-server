{% extends "base.html" %}

{% block page %}
{{ macros.UIJavascript() }}
<style>
	#canvas{
		position:static;
	}
</style>
<div class="container-fluid" id="contFl">
	<div class="row">
		<div class="col-md-8">
			<div id="canvas">
			</div>
		</div>
		<div class="col-md-3"
			<div id="datGui">
			</div>
		</div>
	</div>
</div>

<script>//Recursive draw structure (tree) function
	/**
	 * Recursively draws the structure tree using three.js and some jQuery
	 * @param tree A system tree from the CityFarm plantos API
	 * @param items the three.js Object3D the top node will be added to
	 * @param parentPos *optional* a 3-element list of ints for the position of the parent. 
	 * 		Default value is [0,0,0]
	 */
	function drawTree(node, items, parentPos, parent){
		//draw top node
		parentPos = parentPos || [0,0,0];
		
		var childBool = ("children" in node);
		var obj, mat;
		if(node.hasOwnProperty('model3d')){ //Use 3d model (must be collada file)
			//return;
			
			var loader = new THREE.ColladaLoader();
			loader.options.convertUpAxis = true;
			modelString = node.model3d;
			
			loader.load(modelString, loadObj);
			function loadObj(coll){
				var matColor = 0xdd0000;
				mat = new THREE.MeshLambertMaterial({color:matColor});
				obj = coll.scene;
				//Set position
				obj.position.set(
					parentPos[0]+node.x,
					parentPos[2]+node.z,
					parentPos[1]+node.y+node.width
				);

				//Scale to correct size
				obj.scale.x = obj.scale.x*(node.length/node.objectDims[0]);
				obj.scale.y = obj.scale.y*(node.height/node.objectDims[1]);
				obj.scale.z = obj.scale.z*(node.width/node.objectDims[2]);

				//get all meshes in an object
				obj.meshes = [];
				findMeshes(obj, obj.meshes);

				//set object porperties
				obj.node = node;
				obj.meshes.forEach(function(mesh){
					mesh.originalColor = mesh.material.color;
					mesh.node = node;
				} );

				//set node object
				node.obj = obj;
				//node.parent = parent;
				items.add(obj);

				if (childBool){
					var myPos = [node.x+parentPos[0], node.y+parentPos[1], node.z+parentPos[2]]
					for (var child in node.children){
						Plantos.recursiveCounter+=1;
						drawTree(node.children[child], items, myPos, node );
					}
				}
				Plantos.recursiveCounter--;
				if(Plantos.recursiveCounter == 0){
					start();
				}
			}
		}
		else{ //If no 3d model is provided - Uses boxes and wireframes
			var geo, mat;
			var matColor = 0x00bb00;
			geo = new THREE.BoxGeometry(node.length, node.height, node.width);
			if('children' in node){
				matColor = 0x007700;
				mat = new THREE.MeshBasicMaterial({color:matColor, wireframe:true});
			}
			else{
				mat = new THREE.MeshLambertMaterial({color:matColor});
			}
			obj = new THREE.Mesh(geo, mat);

			obj.position.set(
				node.x + node.length/2 + parentPos[0],
				node.z + node.height/2 + parentPos[2],
				node.y + node.width /2 + parentPos[1]
			);
			obj.originalColor = mat.color;
			obj.node = node
			node.obj = obj;
			node.parent = parent;
			items.add(obj);
			if (childBool){
				var myPos = [node.x, node.y, node.z]
				for (var child in node.children){
					Plantos.recursiveCounter+=1;
					drawTree(node.children[child], items, myPos, node );
				}
			}
			Plantos.recursiveCounter--;
			if(Plantos.recursiveCounter == 0){		
				start();
			}
		}
	}

</script>

<script>//Helper Functions
	var mouse = new THREE.Vector3();
	function onClick(){
		if(!("children" in PlantosRoot.node)){
			return;
		}
		if(intersects_now.length>0){
			//Gets clicked object
			clickedObject = intersects_now[0];
			
			Plantos.updateRootNode(PlantosRoot, clickedObject.object.node, clickable, structureList);
			moveCameraToObject(camera, PlantosRoot.node);
			Plantos.setOpacity(PlantosRoot.node, 1/OpacityFactor)
			if(!("children" in PlantosRoot.node)){
				console.log("New Query Here!");
			}
		}
	}
	function moveCameraToObject(camera, node){
		camFOV = (Math.PI/180.0)*camera.fov;
		camFOVx = Math.atan(containerRatio*Math.tan(camFOV/2))
		var zRelx = (node.length/2)*containerRatio/2 / Math.tan(camFOVx);
		var zRely = (node.height/2) / Math.tan(camFOV/2);
		var zRelMax = Math.max(zRelx, zRely);
		var zOff = zRelMax*1.15+node.width;
		
		var xOff = 0; //= zRelMax*Math.sin(-camera.rotation.y);
		var yOff = zOff*Math.tan(-camera.rotation.x);
		cameraMove = true;
		if(node.hasOwnProperty('model3d')){
			xOff += node.length/2;
			yOff += node.height/2;
			zOff -= node.width/2;
		}
		cameraTarget.x = node.obj.position.x + xOff;
		cameraTarget.y = node.obj.position.y + yOff;
		cameraTarget.z = node.obj.position.z + zOff;
	}
</script>

<script>//Event Listeners
	window.addEventListener( 'mousemove', onMouseMove, false);
	window.addEventListener( 'resize', onWindowResize, false );
	window.addEventListener( 'click', onClick, false);
</script>

<script>//Render Loop
	var intersects_now = {};
	var intersected;
	var animate;
	var ray = new THREE.Raycaster();
	var render = function () {
		animate = requestAnimationFrame( render );
		renderer.render(scene, camera);
		ray.setFromCamera(mouse, camera);
		//ray.setSource(camera.position, mouse)
		intersected = intersects_now;
		intersects_now = ray.intersectObjects(clickable.children, true);

		guiFunc.currentSelection = PlantosRoot.node.url;
		
		//Update colors if necessary
		var hoverColor = new THREE.Color( 0xFFFF66 );
		if(intersects_now.length>0){
			if(intersected.length>0){
				if(intersects_now[0].object != intersected[0].object){
					setColor(intersected[0].object, intersected[0].object.originalColor);
					setColor(intersects_now[0].object, hoverColor);
				}
			}
			else{
				setColor(intersects_now[0].object, hoverColor);
			}
		}
		else{
			if(intersected.length>0){
				setColor(intersected[0].object, intersected[0].object.originalColor);
			}
		}

		//Move camera if necessary - FIND A BETTER WAY
		if(cameraMove){
			var moveSpeed = 0.5/6;
			if (Math.abs(camera.position.x-cameraTarget.x)<2*moveSpeed &&
				Math.abs(camera.position.y-cameraTarget.y)<2*moveSpeed &&
				Math.abs(camera.position.z-cameraTarget.z)<2*moveSpeed){
				cameraMove = false;
			}
			//move the camera ... find a better way, make a function
			else{
				if(camera.position.x>cameraTarget.x+moveSpeed){
					camera.position.x -= moveSpeed;
				}
				else if(camera.position.x<cameraTarget.x-moveSpeed){
					camera.position.x += moveSpeed;
				}
				
				if(camera.position.y>cameraTarget.y+moveSpeed){
					camera.position.y -= moveSpeed;
				}
				else if(camera.position.y<cameraTarget.y-moveSpeed){
					camera.position.y += moveSpeed;
				}
				
				if(camera.position.z>cameraTarget.z+moveSpeed){
					camera.position.z -= moveSpeed;
				}
				else if(camera.position.z<cameraTarget.z-moveSpeed){
					camera.position.z += moveSpeed;
				}
				
				camera.updateProjectionMatrix();
			}
		}	
	};
</script>


<script>
	function start(){
		moveCameraToObject(camera, PlantosRoot.node);
		camera.position.x = cameraTarget.x;
		camera.position.y = cameraTarget.y;
		camera.position.z = cameraTarget.z;
		//Initial Clikacable elements
		clickable = new THREE.Object3D();
		Plantos.addChildren(clickable, PlantosRoot.node);
		scene.add(clickable);
		PlantosRoot.node.obj.meshes.forEach(function(box){box.material.opacity = 0.4;});
		render();
	}
</script>


<script> //Setup (CityFarm)
	//Initial Query
	var enclosure = {{ queryData|safe }};
	//Set Current data URL
	var url = enclosure["url"];

	//Debug Setup
	var aisle = enclosure["children"][0];
	var bay1 = aisle.children[1];

	//CityFarm Website Element and Dimension
	var $cont = $("#canvas");
	var containerWidth = $cont.width();
	var containerRatio = 16.0/9.0;
	var containerHeight = containerWidth*1.0/containerRatio;
	//Set Initial Current root - usually Enclosure (or initially passed container)
	var currentRoot = aisle;

	//Setup PlantOS API Objects
	var PlantosRoot = new Plantos.Node(enclosure);
	var OpacityFactor = 5.0;

	//Three.js Setup
	//Scene, Camera, Light
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera( 60, containerWidth/containerHeight, 0.1, 100 );
	var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
	scene.add( directionalLight );

	
	//Renderer
	var renderer = new THREE.WebGLRenderer({ alpha:true });
	renderer.setSize( containerWidth, containerHeight );
	renderer.setClearColor(0x005500, 0.25);
	$cont.append( renderer.domElement );


	//Initial Setup
	directionalLight.position.set( 15, 17.5, 15.5 );
	directionalLight.rotation.x = -3.5;

	//camera.position.set(5,4,5.5);
	camera.rotation.x = -0.1;
	var structureList = new THREE.Object3D();
	scene.add(structureList);
	var cameraMove = false;
	var cameraTarget = new THREE.Vector3(camera.position);
	var clickable;

	//Draw the structure
	Plantos.recursiveCounter = 1;
	drawTree(PlantosRoot.node, structureList, [0,0,0], "No Parent");
	//$.when(drawTree(PlantosRoot.node, structureList, [0,0,0], "No Parent")).then(start());
	
</script>

<script>//DAT.GUI
	var gui = new dat.GUI({autoPlace:false});
	var customContainer = document.getElementById('datGui');
	customContainer.appendChild(gui.domElement);
	
	var bigViewGui = function(){
		this.backCam = function(){
			if(PlantosRoot.node.parent != "No Parent"){
				Plantos.setOpacity(PlantosRoot.node, OpacityFactor);
				Plantos.updateRootNode(PlantosRoot, PlantosRoot.node.parent, clickable, structureList);
				moveCameraToObject(camera, PlantosRoot.node);
				
			}
		};
		this.go = function(){
			start();
		};
		this.currentSelection = PlantosRoot.node.url;
		this.testPlant = "Tomato";
		this.testSownDate = "5/4/2015"
	}
	var guiFunc = new bigViewGui();
	
	gui.add(guiFunc, 'currentSelection').listen();//.name("Current Selection");
	
	var f2 = gui.addFolder('Plant');
	f2.add(guiFunc, 'testPlant').name("Type");
	f2.add(guiFunc, 'testSownDate').name("Date Sown");
	var f3 = gui.addFolder('Controls');
	f3.add(guiFunc, 'backCam').name("Zoom Out");
	f2.open();
	f3.open();
</script>

<script>//Move the camera/light - Only for debuging
	
	//Detect Arrow key press
	document.onkeydown = function(e){
		if(e.keyCode == 37){
			leftKeyDown();
		}
		else if(e.keyCode == 38){
			upKeyDown();
		}
		else if(e.keyCode == 39){
			rightKeyDown();
		}
		else if(e.keyCode == 40){
			downKeyDown();
		}
		else if(e.keyCode == 87){
			wKeyDown();
		}
		else if(e.keyCode == 65){
			aKeyDown();
		}
		else if(e.keyCode == 83){
			sKeyDown();
		}else if(e.keyCode == 68){
			dKeyDown();
		}
		else if(e.keyCode == 80){
			pKeyDown();
		}
		else if(e.keyCode == 76){
			lKeyDown();
		}
		camera.updateProjectionMatrix();
	}
	//actually move it
	var camMoveAmount = 0.05;
	var camRotAmt = 2*2*Math.PI/360.0
	var lightMoveAmt = 3;
	//Move cameras and lights
	function upKeyDown(){
		camera.position.y -=camMoveAmount;
	//	directionalLight.position.y -=lightMoveAmt;
	}
	function downKeyDown(){
		camera.position.y +=camMoveAmount;
	//	directionalLight.position.y +=lightMoveAmt;
	}
	function rightKeyDown(){
		camera.position.x -=camMoveAmount;
	//	directionalLight.position.x -=lightMoveAmt;
	}
	function leftKeyDown(){
		camera.position.x +=camMoveAmount;
	//	directionalLight.position.x +=lightMoveAmt;
	}
	function pKeyDown(){
		camera.position.z +=camMoveAmount;
	//	directionalLight.position.z +=camMoveAmount;
	}
	function lKeyDown(){
		camera.position.z -=camMoveAmount;
	//	directionalLight.position.z -=camMoveAmount;
	}
	//Rotate cam/light
	function wKeyDown(){
		camera.rotation.x +=camRotAmt;
	//	directionalLight.rotation.x -=camMoveAmount;
	}
	function sKeyDown(){
		camera.rotation.x -=camRotAmt;
	//	directionalLight.rotation.x +=camMoveAmount;
	}
	function aKeyDown(){
		camera.rotation.y +=camRotAmt;
	//	directionalLight.rotation.x +=camMoveAmount;
	}
	function dKeyDown(){
		camera.rotation.y -=camRotAmt;
	//	directionalLight.rotation.x +=camMoveAmount;
	}
</script>
{% endblock %}